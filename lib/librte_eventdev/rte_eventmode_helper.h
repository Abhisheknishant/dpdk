/* SPDX-License-Identifier: BSD-3-Clause
 * Copyright (C) 2019 Marvell International Ltd.
 */
#ifndef _RTE_EVENTMODE_HELPER_H_
#define _RTE_EVENTMODE_HELPER_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <rte_common.h>
#include <rte_compat.h>
#include <rte_config.h>
#include <rte_event_eth_tx_adapter.h>

/* Flag to indicate that the event device used by all adapters is same */
#define RTE_EM_HELPER_TX_EV_LINK_COMMON_EVENT_DEV	(1 << 0)

/* Flag to indicate that the event queue to be used for all adapters is same */
#define RTE_EM_HELPER_TX_EV_LINK_COMMON_EVENT_QUEUE	(1 << 1)

/* Packet transfer mode of the application */
enum rte_eventmode_helper_pkt_transfer_mode {
	RTE_EVENTMODE_HELPER_PKT_TRANSFER_MODE_POLL = 0,
	RTE_EVENTMODE_HELPER_PKT_TRANSFER_MODE_EVENT,
};

/* Event mode packet rx types */
enum rte_eventmode_helper_rx_types {
	RTE_EVENTMODE_HELPER_RX_TYPE_INVALID = 0,
	RTE_EVENTMODE_HELPER_RX_TYPE_NON_BURST,
	RTE_EVENTMODE_HELPER_RX_TYPE_BURST,
	RTE_EVENTMODE_HELPER_RX_TYPE_MAX = 16
};

/* Event mode packet tx types */
enum rte_eventmode_helper_tx_types {
	RTE_EVETNMODE_HELPER_TX_TYPE_INVALID = 0,
	RTE_EVENTMODE_HELPER_TX_TYPE_MAX = 16
};

struct rte_eventmode_helper_conf {
	enum rte_eventmode_helper_pkt_transfer_mode mode;
		/**< Packet transfer mode of the application */
	uint32_t eth_portmask;
		/**<
		 * Mask of the eth ports to be used. This portmask would be
		 * checked while initializing devices using helper routines.
		 */
	void *mode_params;
		/**< Mode specific parameters */
};

/* Event-lcore link conf */
struct rte_eventmode_helper_event_link_info {
	uint8_t eventdev_id;
		/**< Event device ID */
	uint8_t event_portid;
		/**< Event port ID */
	uint8_t eventq_id;
		/**< Event queue to be linked to the port */
	uint8_t lcore_id;
		/**< Lcore to be polling on this port */
};

/*
 * Tx event queue - port link conf
 *
 * Application would need to know which event queue would correspond to which
 * eth port, so that it can send out accordingly.
 */
struct rte_eventmode_helper_tx_ev_link_conf {
	uint8_t flags;
	struct {
		uint8_t eventdev_id;
			/**< Event device ID */
		uint8_t tx_ev_queue;
			/**< Tx event queue */
	} ports[RTE_MAX_ETHPORTS];
};

/* Workers registered by the application */
struct rte_eventmode_helper_app_worker_params {
	union {
		struct {
			uint64_t burst : 4;
			/**< Specify status of rx type burst */
		};
		uint64_t u64;
	} cap;
			/**< Capabilities of this worker */
	void (*worker_thread)(void *mode_conf);
			/**< Worker thread */
};

/* Common helper functions for command line parsing */

/**
 * Print event mode options list
 *
 */
void __rte_experimental
rte_eventmode_helper_print_options_list(void);

/**
 * Print event mode options description
 *
 */
void __rte_experimental
rte_eventmode_helper_print_options_description(void);

/**
 * Parse event mode arguments
 *
 * The application can call this function in it's argument parsing routine to
 * parse the event mode specific args and create the conf accordingly. This
 * function is to be executed on the MASTER lcore only.
 *
 * @param argc
 *   A non-negative value. If it is greater than 0, the array members
 *   for argv[0] through argv[argc] (non-inclusive) shall contain pointers
 *   to strings.
 * @param argv
 *   An array of strings. The contents of the array, as well as the strings
 *   which are pointed to by the array, may be modified by this function.
 * @return
 *   Configuration generated by parsing the event mode args.
 */
struct rte_eventmode_helper_conf * __rte_experimental
rte_eventmode_helper_parse_args(int argc, char **argv);

/* Helper functions for initialization, & launching workers */

/**
 * Initialize event mode devices
 *
 * Application could call this function to get the event device, eth device
 * and eth rx adapter initialized according to the conf populated using the
 * command line args.
 *
 * Application is expected to initialize the eth device and then the eventmode
 * helper subsystem will stop & start eth device according to it's requirement.
 * So call to this function should be done after the eth device is successfully
 * initialized.
 *
 * @param mode_conf
 *   Configuration of the mode in which app is doing packet handling
 * @return
 *  - 0 on success.
 *  - (<0) on failure.
 */
int32_t __rte_experimental
rte_eventmode_helper_initialize_devs(
		struct rte_eventmode_helper_conf *mode_conf);

/**
 * Display event mode conf
 *
 * Parse the conf and display the current configuration.
 *
 * @param mode_conf
 *   Configuration of the mode in which app is doing packet handling
 */
void __rte_experimental
rte_eventmode_helper_display_conf(struct rte_eventmode_helper_conf *mode_conf);

/**
 * Get event dev - lcore links
 *
 * Since the execution loop is in the application, the application would need
 * the info on which event port to be polled by an lcore etc. This helper
 * function would help the application in doing so. The 'links' would point
 * to the memory allocated for the links list, and the application should
 * release this, once the use is over.
 *
 * @param lcore_id
 *   ID of the lcore for which the links list need to be populated
 * @param mode_conf
 *   Configuration of the mode in which app is doing packet handling
 * @param links
 *   Used to pass the pointer of the memory allocated by the helper to the
 *   application
 * @return
 *   Number of links found for the lcore
 */
uint8_t __rte_experimental
rte_eventmode_helper_get_event_lcore_links(uint32_t lcore_id,
		struct rte_eventmode_helper_conf *mode_conf,
		struct rte_eventmode_helper_event_link_info **links);

/**
 * Get eventdev tx queue
 *
 * If the application uses event device which does not support internal port
 * then it needs to submit the events to an atomic Tx queue before final
 * transmission. The Tx queue will be atomic to make sure that ingress order of
 * the packets is maintained. This Tx queue will be created internally by the
 * eventmode helper subsystem, and application will need it's queue ID when it
 * is running the execution loop.
 *
 * @param mode_conf
 *   Configuration of the mode in which app is doing packet handling
 * @param eventdev_id
 *   Event device ID
 * @return
 *   Tx queue ID
 */
uint8_t __rte_experimental
rte_eventmode_helper_get_tx_queue(struct rte_eventmode_helper_conf *mode_conf,
		uint8_t eventdev_id);

/**
 * Launch eventmode worker
 *
 * The application can request the eventmode helper subsystem to launch the
 * worker based on the capabilities of event device and the options selected
 * while initializing the eventmode.
 *
 * @param mode_conf
 *   Configuration of the mode in which app is doing packet handling
 * @param app_wrkr
 *   List of all the workers registered by application, along with it's
 *   capabilities
 * @param nb_wrkr_param
 *   Number of workers passed by the application
 *
 */
void __rte_experimental
rte_eventmode_helper_launch_worker(struct rte_eventmode_helper_conf *mode_conf,
		struct rte_eventmode_helper_app_worker_params *app_wrkr,
		uint8_t nb_wrkr_param);

#ifdef __cplusplus
}
#endif

#endif /* _RTE_EVENTMODE_HELPER_H_ */
